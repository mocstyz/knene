\## 13. 代码注释规范 (强制执行)



\### 13.1 注释规范原则



\*\*⚠️ 强制要求：所有代码文件必须遵循统一的注释规范，提高代码可读性和维护性。\*\*



\#### 13.1.1 注释风格原则



\- \*\*简洁美观\*\*：避免冗余的装饰性注释，追求简洁清晰

\- \*\*行内优先\*\*：参数、属性等使用行内注释，避免块注释

\- \*\*内容为王\*\*：注释内容要准确、有用，避免无意义的重复

\- \*\*统一格式\*\*：全项目使用统一的注释格式和风格



\#### 13.1.2 注释长度规则



\*\*⚠️ 强制要求：\*\*

\- \*\*所有函数、接口、组件、类型定义\*\*：统一使用单行注释 `//`，不允许使用多行JSDoc注释

\- \*\*文件头注释\*\*：使用块注释 `/\*\* \*/`

\- \*\*禁止多行单行注释\*\*：不允许出现连续的 `//` 注释行



\*\*注释原则说明：\*\*

\- 简化注释格式，提高代码可读性

\- 所有业务代码注释统一使用单行格式

\- 只有文件头保留JSDoc格式用于文档生成



\*\*✅ 正确的单行注释格式：\*\*

```typescript

// 响应式列数配置接口，统一各模块的列数配置格式

export interface ResponsiveColumnsConfig {

&nbsp; // 处理用户登录逻辑，验证凭据并返回认证状态

&nbsp; handleLogin(credentials: LoginCredentials): Promise<AuthResult>

}

```



\*\*❌ 错误的注释格式：\*\*

```typescript

// ❌ 禁止：多行单行注释

// 响应式列数配置接口

// 统一各模块的列数配置格式

export interface ResponsiveColumnsConfig {

&nbsp; // 处理用户登录逻辑

&nbsp; // 验证凭据并返回认证状态

&nbsp; handleLogin(credentials: LoginCredentials): Promise<AuthResult>

}



// ❌ 禁止：JSDoc格式

/\*\*

&nbsp;\* 响应式列数配置接口

&nbsp;\* 统一各模块的列数配置格式

&nbsp;\*/

export interface ResponsiveColumnsConfig {

&nbsp; /\*\*

&nbsp;  \* 处理用户登录逻辑

&nbsp;  \* @param credentials 登录凭据

&nbsp;  \* @returns 认证结果

&nbsp;  \*/

&nbsp; handleLogin(credentials: LoginCredentials): Promise<AuthResult>

}

```

```



\### 13.2 文件头注释规范



\#### 13.2.1 标准文件头格式



```typescript

/\*\*

&nbsp;\* @fileoverview 文件功能简述

&nbsp;\* @description 详细描述文件的作用和主要功能，解释设计思路。

&nbsp;\*              文件头的@description可以是多行详细描述，不受单行注释规则限制。

&nbsp;\*              可以包含文件的核心功能、设计理念、架构说明等详细信息。

&nbsp;\* @created 2025-10-17 10:00:53

&nbsp;\* @updated 2025-10-17 16:21:08

&nbsp;\* @author mosctz

&nbsp;\* @since 1.0.0

&nbsp;\* @version 1.0.0

&nbsp;\*/

```



\#### 13.2.2 文件头字段说明



\- \*\*@fileoverview\*\*：文件功能的简短概述（必填）

\- \*\*@description\*\*：详细描述文件作用、设计思路（必填）
  - 文件头的@description可以是多行详细描述，不受单行注释规则限制
  - 可以包含文件的核心功能、设计理念、架构说明等详细信息
  - 与业务代码注释不同，文件头@description允许换行和详细说明

\- \*\*@created\*\*：文件真实创建时间，格式：YYYY-MM-DD HH:mm:ss（必填）

&nbsp; - **必须使用Git历史记录获取文件首次提交时间**，而非文件系统时间
&nbsp; - 文件系统时间会因为编辑操作而改变，只有Git历史记录是准确的
&nbsp; - Git获取命令：`git log --follow --reverse --format="%ad" --date=format:"%Y-%m-%d %H:%M:%S" -- "文件路径" | head -1`

\- \*\*@updated\*\*：当前修改时间，格式：YYYY-MM-DD HH:mm:ss（必填）

&nbsp; - 每次修改文件时更新为当前时间，而非历史修改时间

&nbsp; - PowerShell获取当前时间：`Get-Date -Format "yyyy-MM-dd HH:mm:ss"` ，当你修改到哪个文件，就执行这个命令获取当前的时间

\- \*\*@author\*\*：文件作者（必填）

\- \*\*@since\*\*：首次引入的版本号（必填）

\- \*\*@version\*\*：当前版本号（必填）



\#### 13.2.3 文件头示例



```typescript

/\*\*

&nbsp;\* @fileoverview 统一接口类型定义

&nbsp;\* @description 定义统一的Section Props和Card Config接口，消除重复代码，提高一致性

&nbsp;\* @created 2025-10-17 10:00:53

&nbsp;\* @updated 2025-10-17 16:21:08

&nbsp;\* @author mosctz

&nbsp;\* @since 1.0.0

&nbsp;\* @version 1.0.0

&nbsp;\*/

```



\*\*时间戳说明：\*\*

\- `@created` **必须使用Git历史记录获取文件首次提交时间**
  - 文件系统时间会因为编辑操作而改变，不准确
  - 只有Git历史记录保存了文件的真实创建时间
  - 通过Git命令获取：`git log --follow --reverse --format="%ad" --date=format:"%Y-%m-%d %H:%M:%S" -- "文件路径" | head -1`

\- `@updated` 使用当前修改时间，每次修改文件时都应更新此字段

#### 13.2.4 获取文件真实创建时间的最佳实践

\*\*⚠️ 重要说明：为什么必须使用Git历史获取创建时间\*\*

在使用编辑工具（如VS Code、AI助手等）修改文件时，文件系统的创建时间会被重置为当前时间。这是因为编辑工具通常采用"删除原文件，创建新文件"的工作方式。

\*\*正确的获取方法：\*\*

1. \*\*使用Git历史记录（推荐）\*\*
   ```bash
   # 获取单个文件的创建时间
   git log --follow --reverse --format="%ad" --date=format:"%Y-%m-%d %H:%M:%S" -- "文件路径" | head -1

   # 示例
   git log --follow --reverse --format="%ad" --date=format:"%Y-%m-%d %H:%M:%S" -- "src/components/Button.tsx" | head -1
   ```

2. \*\*批量获取多个文件的创建时间\*\*
   ```bash
   # 获取目录下所有文件的创建时间
   for file in src/components/*.tsx; do
     echo "=== $file ==="
     git log --follow --reverse --format="%ad" --date=format:"%Y-%m-%d %H:%M:%S" -- "$file" | head -1
   done
   ```

\*\*命令参数说明：\*\*
- `--follow`：跟踪文件重命名历史
- `--reverse`：按时间正序显示（最早的在前）
- `--format="%ad"`：只显示作者日期
- `--date=format:"%Y-%m-%d %H:%M:%S"`：格式化时间输出
- `| head -1`：只取第一行（最早的提交）

\*\*错误的方法（不要使用）：\*\*
- ❌ Windows文件系统属性
- ❌ PowerShell的 `(Get-Item).CreationTime`
- ❌ Linux的 `stat` 命令
- ❌ 任何基于文件系统时间的获取方式

\*\*工作流程建议：\*\*
1. 修改文件前，先用Git命令获取真实创建时间
2. 修改文件头注释中的 `@created` 字段
3. 设置 `@updated` 为当前时间
4. 提交代码时，确保时间信息准确



\### 13.3 接口和类型注释规范



\#### 13.3.1 接口注释格式



\*\*⚠️ 强制要求：所有接口和类型必须使用单行注释格式，不允许使用多行JSDoc注释。\*\*



```typescript

// 响应式列数配置接口，统一各模块的列数配置格式

export interface ResponsiveColumnsConfig {

&nbsp; xs?: number // 超小屏幕断点配置

&nbsp; sm?: number // 小屏幕断点配置

&nbsp; md?: number // 中等屏幕断点配置

&nbsp; lg?: number // 大屏幕断点配置

&nbsp; xl?: number // 超大屏幕断点配置

&nbsp; xxl?: number // 超超大屏幕断点配置

}



// 统一卡片配置接口，定义所有卡片组件的通用配置选项，支持多种布局变体和显示选项

export interface UnifiedCardConfig {

&nbsp; variant?: 'grid' | 'list' | 'carousel' // 布局变体

&nbsp; columns?: ResponsiveColumnsConfig // 响应式列数配置

&nbsp; showVipBadge?: boolean // 是否显示VIP标签

&nbsp; showNewBadge?: boolean // 是否显示新片标签

&nbsp; aspectRatio?: 'square' | 'video' | 'portrait' | 'landscape' // 卡片宽高比

&nbsp; hoverEffect?: boolean // 悬停效果开关

&nbsp; className?: string // 自定义CSS类名

}

```

```



\### 13.4 函数和方法注释规范



\#### 13.4.1 函数注释格式



\*\*⚠️ 强制要求：所有函数和方法必须使用单行注释格式，不允许使用多行JSDoc注释。\*\*



```typescript

// 检查是否为有效的响应式列数配置

export function isValidColumnsConfig(config: any): config is ResponsiveColumnsConfig {

&nbsp; return (

&nbsp;   config \&\&

&nbsp;   typeof config === 'object' \&\&

&nbsp;   Object.keys(config).every(key => 

&nbsp;     \['xs', 'sm', 'md', 'lg', 'xl', 'xxl'].includes(key) \&\&

&nbsp;     typeof config\[key] === 'number' \&\&

&nbsp;     config\[key] > 0

&nbsp;   )

&nbsp; )

}



// 合并Section Props配置，将默认配置和用户配置进行深度合并，确保配置的完整性和一致性

export function mergeSectionProps<T>(

&nbsp; defaultProps: Partial<BaseSectionProps<T>>, // 默认配置

&nbsp; userProps: Partial<BaseSectionProps<T>> // 用户自定义配置

): BaseSectionProps<T> {

&nbsp; return {

&nbsp;   ...defaultProps,

&nbsp;   ...userProps,

&nbsp;   cardConfig: {

&nbsp;     ...createDefaultCardConfig(),

&nbsp;     ...defaultProps.cardConfig,

&nbsp;     ...userProps.cardConfig,

&nbsp;   },

&nbsp;   columns: {

&nbsp;     ...createDefaultColumnsConfig(),

&nbsp;     ...defaultProps.columns,

&nbsp;     ...userProps.columns,

&nbsp;   },

&nbsp; } as BaseSectionProps<T>

}



// 计算折扣价格

export function calculateDiscount(price: number, percentage: number): number {

&nbsp; return price \* (percentage / 100)

}



// 处理支付请求，支持多种货币和支付选项配置

export function processPayment(

&nbsp; amount: number, // 支付金额，单位：分

&nbsp; currency: string, // 货币代码，如 'CNY', 'USD'

&nbsp; options?: PaymentOptions // 支付选项配置

): Promise<PaymentResult> {

&nbsp; // 实现...

}

```



\### 13.5 组件注释规范



\#### 13.5.1 React组件注释



\*\*⚠️ 强制要求：所有React组件必须使用单行注释格式，不允许使用多行JSDoc注释。\*\*



```typescript

// 影片卡片组件，支持多种布局变体和交互效果

export const MovieCard: React.FC<MovieCardProps> = ({

&nbsp; movie, // 影片数据

&nbsp; variant = 'grid', // 布局变体，默认网格布局

&nbsp; showRating = true, // 是否显示评分

&nbsp; onClick, // 点击事件处理器

&nbsp; className // 自定义样式类名

}) => {

&nbsp; // 组件实现...

}



// 基础按钮组件

export const Button: React.FC<ButtonProps> = ({

&nbsp; children,

&nbsp; type = 'button',

&nbsp; disabled = false,

&nbsp; onClick

}) => {

&nbsp; // 组件实现...

}



// 影片合集列表组件，提供影片合集的完整列表功能，使用内容渲染器系统支持多种布局和交互

const CollectionList: React.FC<CollectionListProps> = ({

&nbsp; collections,

&nbsp; pagination,

&nbsp; onCollectionClick,

&nbsp; className,

&nbsp; // 其他props...

}) => {

&nbsp; // 组件实现...

}

```



\#### 13.5.2 Hook注释



\*\*所有Hook必须使用单行注释格式：\*\*



```typescript

// 影片数据管理Hook，提供影片列表的获取、搜索、筛选功能

export const useMovies = (

&nbsp; category?: string, // 影片分类

&nbsp; searchTerm?: string // 搜索关键词

) => {

&nbsp; // Hook实现...

}



// 切换状态Hook

export const useToggle = (initialValue: boolean = false) => {

&nbsp; const \[value, setValue] = useState(initialValue)

&nbsp; const toggle = useCallback(() => setValue(prev => !prev), \[])

&nbsp; return \[value, toggle] as const

}



// 统一内容管理Hook，提供统一的内容数据管理功能，支持多种内容类型和缓存机制

export const useUnifiedContent = <T>(

&nbsp; contentType: ContentType, // 内容类型

&nbsp; options?: ContentOptions // 配置选项

) => {

&nbsp; // Hook实现...

}

```



\### 13.6 常量和变量注释规范



\#### 13.6.1 常量注释



```typescript

// API接口地址配置

export const API\_ENDPOINTS = {

&nbsp; MOVIES: '/api/movies', // 影片列表接口

&nbsp; MOVIE\_DETAIL: '/api/movies/:id', // 影片详情接口

&nbsp; SEARCH: '/api/search', // 搜索接口

&nbsp; USER\_PROFILE: '/api/user/profile' // 用户资料接口

} as const



// 默认分页配置

export const DEFAULT\_PAGINATION = {

&nbsp; page: 1, // 当前页码

&nbsp; pageSize: 20, // 每页条数

&nbsp; total: 0 // 总条数

}

```



\#### 13.6.2 枚举注释



```typescript

// 影片状态枚举

export enum MovieStatus {

&nbsp; DRAFT = 'draft', // 草稿状态

&nbsp; PUBLISHED = 'published', // 已发布

&nbsp; ARCHIVED = 'archived', // 已归档

&nbsp; DELETED = 'deleted' // 已删除

}

```



\### 13.7 注释禁用规则



\#### 13.7.1 禁止使用的注释格式



\*\*❌ 禁止：所有函数、接口、组件、类型使用JSDoc块注释\*\*



```typescript

// ❌ 错误示例 - 任何业务代码都不应使用JSDoc块注释

/\*\*

&nbsp;\* 响应式列数配置接口

&nbsp;\*/

export interface ResponsiveColumnsConfig {

&nbsp; xs?: number

}



/\*\*

&nbsp;\* 处理用户登录

&nbsp;\* @param credentials 登录凭据

&nbsp;\* @returns 认证结果

&nbsp;\*/

export function handleLogin(credentials: LoginCredentials): Promise<AuthResult> {

&nbsp; // 实现...

}



// ✅ 正确示例 - 统一使用单行注释

// 响应式列数配置接口

export interface ResponsiveColumnsConfig {

&nbsp; xs?: number // 超小屏幕 (< 640px)

}



// 处理用户登录，验证凭据并返回认证状态

export function handleLogin(credentials: LoginCredentials): Promise<AuthResult> {

&nbsp; // 实现...

}

```



\*\*❌ 禁止：多行单行注释\*\*



```typescript

// ❌ 错误示例 - 不允许多行单行注释

// 影片合集列表组件

// 提供影片合集的完整列表功能，使用内容渲染器系统

// 使用BaseList提供统一布局

// 使用CollectionContentRenderer提供影片合集卡片渲染

const CollectionList: React.FC<CollectionListProps> = ({ ... }) => { ... }



// ✅ 正确示例 - 使用单行注释

// 影片合集列表组件，提供影片合集的完整列表功能，使用内容渲染器系统支持多种布局和交互

const CollectionList: React.FC<CollectionListProps> = ({ ... }) => { ... }

```



\#### 13.7.2 参数注释规则



\*\*⚠️ 强制要求：参数、属性、字段的注释遵循以下规则：\*\*



\*\*注释原则：\*\*

1\. \*\*简单明了的参数\*\*：一看就懂的参数不需要添加注释

2\. \*\*重要和关键参数\*\*：必须使用行内注释格式说明

3\. \*\*避免过度注释\*\*：不要为每个参数都添加注释，只注释真正需要说明的



\*\*需要注释的参数类型：\*\*

\- \*\*业务逻辑相关\*\*：涉及特定业务规则或约束的参数

\- \*\*可选参数\*\*：需要说明默认行为或使用场景的可选参数

\- \*\*复杂类型\*\*：自定义类型或复杂配置对象

\- \*\*有歧义的参数\*\*：参数名称可能引起误解的

\- \*\*重要回调函数\*\*：关键的事件处理函数

\- \*\*配置选项\*\*：影响组件行为的重要配置



\*\*不需要注释的参数类型：\*\*

\- \*\*基础类型\*\*：如 `title: string`、`id: number` 等显而易见的参数

\- \*\*标准属性\*\*：如 `className`、`style` 等通用属性

\- \*\*简单布尔值\*\*：如 `disabled: boolean`、`visible: boolean` 等



```typescript

// ✅ 正确的参数注释格式 - 只注释重要和关键参数

export interface UserProfile {

&nbsp; id: string

&nbsp; username: string

&nbsp; email: string

&nbsp; avatar?: string // 头像URL，可选

&nbsp; role: 'admin' | 'user' | 'vip' // 用户角色，影响权限控制

&nbsp; createdAt: Date

&nbsp; updatedAt: Date

&nbsp; preferences?: UserPreferences // 用户偏好设置，可选

}



// ✅ 组件Props注释示例 - 只注释关键配置

export interface MovieCardProps {

&nbsp; title: string

&nbsp; year: number

&nbsp; rating: number

&nbsp; poster: string

&nbsp; isVip?: boolean // VIP专享内容标识

&nbsp; onPlay?: (movieId: string) => void // 播放按钮点击回调

&nbsp; variant?: 'compact' | 'detailed' // 卡片显示变体

&nbsp; downloadUrl?: string // 下载链接，仅VIP用户可见

}



// ✅ 函数参数注释示例 - 只注释复杂参数

export function formatRating(

&nbsp; rating: number,

&nbsp; precision = 1 // 小数位数，默认1位

): string {

&nbsp; return rating.toFixed(precision)

}



// ✅ 简单函数参数不需要注释

export function calculateTotal(price: number, quantity: number): number {

&nbsp; return price \* quantity

}

```



\*\*判断标准：\*\*

\- \*\*需要注释\*\*：参数含义不明确、有特殊格式要求、有默认值说明、可选参数的用途

\- \*\*不需要注释\*\*：参数名称已经清楚表达含义，如 `title`、`name`、`id`、`url` 等



\### 13.8 注释内容规范



\#### 13.8.1 注释内容要求



\- \*\*准确性\*\*：注释内容必须与代码实际功能一致

\- \*\*完整性\*\*：重要的参数、返回值、副作用都要说明

\- \*\*简洁性\*\*：避免冗余描述，突出关键信息，显而易见的内容不需要注释

\- \*\*时效性\*\*：代码修改时同步更新注释

\- \*\*3行规则\*\*：描述超过3行的接口、函数、组件必须使用块注释 `/\*\* \*/`，3行及以下使用单行注释 `//`

\- \*\*必要性原则\*\*：只对真正需要说明的内容添加注释，避免过度注释



\#### 13.8.2 注释语言规范



\- \*\*统一语言\*\*：项目内统一使用中文注释

\- \*\*专业术语\*\*：使用准确的技术术语

\- \*\*标点符号\*\*：注释结尾不加句号，除非是完整句子



\#### 13.8.3 注释格式规范详细说明



\*\*统一注释格式：\*\*

\- \*\*文件头注释\*\*：使用JSDoc格式 `/\*\* \*/`，用于文档生成

\- \*\*所有业务代码注释\*\*：统一使用单行注释 `//`，包括函数、接口、组件、类型等

\- \*\*参数注释\*\*：使用行内单行注释 `//`

\- \*\*功能性注释\*\*：使用单行注释 `//`



\*\*注释长度处理：\*\*

\- 无论描述多长，都使用单行注释格式

\- 将多行描述合并为一行，用逗号或句号分隔

\- 保持注释简洁明了，突出关键信息



\*\*示例对比：\*\*



```typescript

// ✅ 正确格式 - 统一使用单行注释

// 用户配置接口，包含基本的用户偏好设置和主题配置

export interface UserConfig {

&nbsp; theme: 'light' | 'dark' // 主题模式

}



// 复杂的影片搜索配置接口，支持多维度搜索条件包括分类年份评分等筛选，提供高级搜索功能支持模糊匹配和精确匹配

export interface MovieSearchConfig {

&nbsp; // 接口定义...

}



// ❌ 错误格式 - 不再使用JSDoc块注释

/\*\*

&nbsp;\* 复杂的影片搜索配置接口

&nbsp;\* 

&nbsp;\* 支持多维度搜索条件，包括分类、年份、评分等筛选。

&nbsp;\* 提供高级搜索功能，支持模糊匹配和精确匹配。

&nbsp;\*/

export interface MovieSearchConfig {

&nbsp; // 接口定义...

}

```



\### 13.9 功能性注释规范



\#### 13.9.1 功能性注释定义



\*\*功能性注释\*\*是对代码块、逻辑段落或关键操作的目的和作用进行说明的注释，采用"功能描述 - 具体说明"的格式。



\*\*格式规范：\*\*

```typescript

// \[功能描述] - \[具体说明/条件/结果]

```



\#### 13.9.2 功能性注释使用场景



\*\*⚠️ 强制要求：以下场景必须添加功能性注释\*\*



1\. \*\*防御性检查\*\*：数据验证、边界条件处理

2\. \*\*数据转换\*\*：格式转换、结构映射、标准化处理

3\. \*\*配置构建\*\*：复杂配置对象的创建和合并

4\. \*\*业务逻辑段落\*\*：关键业务流程的各个步骤

5\. \*\*性能优化\*\*：缓存、懒加载、批处理等优化操作

6\. \*\*状态管理\*\*：状态更新、副作用处理

7\. \*\*条件分支\*\*：复杂的条件判断逻辑



\#### 13.9.3 功能性注释示例



\*\*防御性检查：\*\*

```typescript

// 防御性检查 - 如果collections是undefined或空数组，显示空状态

if (!collections || !Array.isArray(collections) || collections.length === 0) {

&nbsp; return <EmptyState message="暂无数据" />

}



// 参数验证 - 确保必需的配置项存在

if (!config.apiUrl || !config.apiKey) {

&nbsp; throw new Error('缺少必需的API配置')

}

```



\*\*数据转换：\*\*

```typescript

// 数据标准化和默认值设置 - 只设置BaseContentItem中存在的属性

const standardizedData = movies.map(movie => ({

&nbsp; id: movie.id,

&nbsp; title: movie.title || '未知标题',

&nbsp; imageUrl: movie.poster || '/default-poster.jpg'

}))



// 转换最新更新数据为统一内容项格式 - 使用useMemo缓存

const contentItems = useMemo(() => 

&nbsp; latestUpdates.map(item => createMovieContentItem(item)),

&nbsp; \[latestUpdates]

)

```



\*\*配置构建：\*\*

```typescript

// 根据配置创建渲染器配置

const rendererConfig = createRendererConfig({

&nbsp; hoverEffect: cardConfig?.hoverEffect ?? true,

&nbsp; showVipBadge: cardConfig?.showVipBadge ?? true,

&nbsp; aspectRatio: cardConfig?.aspectRatio ?? 'square'

})



// 构建渲染器配置 - 使用useMemo缓存

const config = useMemo(() => ({

&nbsp; layout: getLayoutConfig(variant),

&nbsp; theme: getThemeConfig(mode),

&nbsp; responsive: getResponsiveConfig(breakpoint)

}), \[variant, mode, breakpoint])

```



\*\*业务逻辑段落：\*\*

```typescript

// 获取当前页显示的数据（如果有分页）

const getCurrentPageCollections = () => {

&nbsp; if (!pagination) return collections

&nbsp; 

&nbsp; const { currentPage, itemsPerPage = 12 } = pagination

&nbsp; const startIndex = (currentPage - 1) \* itemsPerPage

&nbsp; const endIndex = startIndex + itemsPerPage

&nbsp; return collections.slice(startIndex, endIndex)

}



// 键盘事件处理 - ESC键关闭菜单

useEffect(() => {

&nbsp; const handleKeyDown = (event: KeyboardEvent) => {

&nbsp;   if (event.key === 'Escape') {

&nbsp;     setIsOpen(false)

&nbsp;   }

&nbsp; }

&nbsp; // ...

}, \[])

```



\*\*性能优化：\*\*

```typescript

// 懒加载图片 - 使用Intersection Observer优化性能

const \[isVisible, setIsVisible] = useState(false)

const imgRef = useRef<HTMLImageElement>(null)



useEffect(() => {

&nbsp; const observer = new IntersectionObserver((\[entry]) => {

&nbsp;   if (entry.isIntersecting) {

&nbsp;     setIsVisible(true)

&nbsp;     observer.disconnect()

&nbsp;   }

&nbsp; })

&nbsp; // ...

}, \[])



// 缓存计算结果 - 避免重复计算

const expensiveValue = useMemo(() => {

&nbsp; return complexCalculation(data)

}, \[data])

```



\#### 13.9.4 功能性注释最佳实践



\*\*✅ 推荐做法：\*\*

\- 使用动词开头，描述具体动作：`获取`、`转换`、`验证`、`构建`

\- 说明处理的条件和预期结果

\- 对复杂逻辑进行分段注释

\- 使用统一的术语和表达方式



\*\*❌ 避免的做法：\*\*

\- 过于简单的描述：`// 设置变量`

\- 重复代码内容：`// 调用fetchData函数`

\- 模糊不清的描述：`// 处理数据`

\- 过时或错误的描述



\#### 13.9.5 功能性注释检查清单



\*\*代码审查时检查：\*\*

\- \[ ] 关键业务逻辑是否有功能性注释？

\- \[ ] 防御性检查是否说明了处理条件？

\- \[ ] 数据转换是否说明了转换目的？

\- \[ ] 复杂配置是否说明了构建逻辑？

\- \[ ] 注释格式是否符合"功能描述 - 具体说明"规范？



\### 13.10 特殊注释标记



\#### 13.10.1 标记类型



```typescript

// TODO: 待实现的功能

// FIXME: 需要修复的问题

// HACK: 临时解决方案

// NOTE: 重要说明

// WARNING: 警告信息

// DEPRECATED: 已废弃的代码

```



\#### 13.10.2 标记使用示例



```typescript

// TODO: 添加缓存机制提升性能

export const fetchMovies = async (params: MovieParams) => {

&nbsp; // FIXME: 错误处理需要优化

&nbsp; try {

&nbsp;   const response = await api.get('/movies', { params })

&nbsp;   return response.data

&nbsp; } catch (error) {

&nbsp;   // WARNING: 临时使用console.error，后续需要接入日志系统

&nbsp;   console.error('获取影片列表失败:', error)

&nbsp;   throw error

&nbsp; }

}



// DEPRECATED: 使用新的 useMoviesQuery Hook 替代

export const useMoviesList = () => {

&nbsp; // 已废弃的实现...

}

```



\### 13.11 注释检查和维护



\#### 13.11.1 自动化检查



\- \*\*ESLint规则\*\*：配置注释相关的ESLint规则

\- \*\*代码审查\*\*：PR审查时检查注释质量

\- \*\*文档生成\*\*：使用工具自动生成API文档



\#### 13.11.2 注释维护原则



\- \*\*同步更新\*\*：代码修改时必须同步更新注释

\- \*\*定期清理\*\*：定期清理过时和无用的注释

\- \*\*质量保证\*\*：确保注释的准确性和有用性

### 13.12 常见问题解答 (FAQ)

#### Q1: 为什么文件系统时间不准确？
**A**: 现代编辑工具（包括VS Code、AI助手等）通常采用"删除原文件，创建新文件"的方式编辑文件，这会导致文件系统的创建时间被重置为当前时间。只有Git版本控制系统保存了文件的真实历史记录。

#### Q2: 如何快速获取多个文件的创建时间？
**A**: 使用以下批量命令：
```bash
# Linux/Mac
for file in src/**/*.ts; do
  echo "=== $file ==="
  git log --follow --reverse --format="%ad" --date=format:"%Y-%m-%d %H:%M:%S" -- "$file" | head -1
done

# Windows PowerShell
Get-ChildItem -Recurse -Filter "*.ts" | ForEach-Object {
  Write-Host "=== $($_.FullName) ==="
  git log --follow --reverse --format="%ad" --date=format:"%Y-%m-%d %H:%M:%S" -- $_.FullName | head -1
}
```

#### Q3: 如果文件没有Git历史记录怎么办？
**A**: 对于新创建的文件：
1. 使用当前时间作为 `@created`
2. 在首次提交时，Git会记录真实的创建时间
3. 后续修改时使用Git历史获取准确的创建时间

#### Q4: Git命令返回空怎么办？
**A**: 可能的原因和解决方案：
1. **文件路径错误**：检查文件路径是否正确
2. **文件未提交**：新文件需要先提交到Git才能获取历史
3. **文件名大小写**：在某些系统中，Git对文件名大小写敏感

#### Q5: 如何验证创建时间是否正确？
**A**:
1. 检查文件的首次提交时间：`git log --follow --oneline -- "文件路径" | tail -1`
2. 查看项目的初始提交时间：`git log --reverse --oneline | head -1`
3. 对比团队成员提交记录，确认时间合理性

#### Q6: 编辑工具自动修改了文件时间怎么办？
**A**:
1. 立即用Git命令重新获取正确的创建时间
2. 更新文件头注释中的 `@created` 字段
3. 设置 `@updated` 为当前时间
4. 提交修正后的注释

#### Q7: 团队协作时如何保持时间一致性？
**A**:
1. 制定团队规范：统一使用Git历史获取创建时间
2. 代码审查时检查 `@created` 字段的准确性
3. 使用CI/CD工具自动验证文件头注释格式
4. 建立检查清单，确保每个文件的时间信息正确

